<!DOCTYPE html>

<head>
    <link rel="shortcut icon" href="static/attachment/treeIcon.png">
    <link rel="stylesheet" href="static/prod.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>

<body>
    <div class="interface">
        <header class="elementLeft">
            <a class="logo" href="http://localhost:5000">Musique Normale</a>
            <p class="sublogo">Digital Sound, Musical Practice</p>
        </header>

        <div class="subinterface">
            <input class="button" type="file" name="audio_files" id="audio_files" webkitdirectory multiple>

            <input class="button" type="button" value="Compute map" id="compute" onclick="computeMap()">
            <a id="text_compute"></a>

            <input class="button" type="button" value="Recenter" id="recenter" onclick="recenter()">

            <div class="containerRadio">
                <p><b>Triggering mode</b></p>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="hover" name="trigger_mode" value="hover"
                        onclick="hoverMode()" checked>
                    <label class="radiobuttonlabel" for="hover">Hover</label>
                </div>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="click" name="trigger_mode" value="click"
                        onclick="clickMode()">
                    <label class="radiobuttonlabel" for="click">Click</label>
                </div>

                <p><b>Playing mode</b></p>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="single" name="playing_mode" value="single"
                        onclick="singleMode()" checked>
                    <label class="radiobuttonlabel" for="single">Single</label>
                </div>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="multiple" name="playing_mode" value="multiple"
                        onclick="multipleMode()">
                    <label class="radiobuttonlabel" for="multiple">Multiple</label>
                </div>
            </div>

            <input class="button" type="button" value="Stop all sounds" id="stop_all_sounds" onclick="stopAllSounds()">

            <button class="button" id="record" onclick="record()">Record</button>
            <button class="button" id="play_record" disabled onclick="playRecord()">Play record</button>

            <a href="" download="Futur tube" id="record_url">
                <button class="button" id="download_record" disabled>Download record</button>
            </a>

            <p id="sound_name"></p>
        </div>
    </div>
    <audio id="audio_player"></audio>
    <audio id="record_player"></audio>

    <canvas id="mapCanvas" class="mapCanvas">
    </canvas>

    <canvas id="visuCanvas" class="visuCanvas">
    </canvas>

    <script>

        // Init
        var background_color = 'rgb(239,239,239)'; // background color
        var c = document.getElementById('mapCanvas');
        var ctx = c.getContext('2d');
        c.width = window.innerWidth;
        c.height = window.innerHeight;

        var cv = document.getElementById('visuCanvas');
        var ctxv = cv.getContext('2d');
        cv.width = window.innerWidth;
        cv.height = window.innerHeight;

        var map = {}; // store the map
        var nbSounds = 0; // total number of sounds in the map
        var positions = []; // position of the sounds on the canvas
        var scale = 1; // change scale to zoom in or out (event wheel)
        var centerX = 0.5; // x coordonate of the center (in the original map referential)
        var centerY = 0.5; // y coordonate of the center (in the original map referential)
        var selected = []; // list of selected sounds
        var pointRadius = 5; // radius of the points
        var grid = null; // store the grid
        initiateGrid(); // initiate the grid

        const sleep = 150; // minimum time between 2 sounds triggering
        const sleep_same = 500; // minimum time between 2 triggering of the same sound
        let last = Date.now(); // last time a sound was played
        let last_same = Date.now(); // last time the sound we want to replay has been played
        var last_played = null; // last sound that has been played

        var down = false; // store the state of the mouse button
        var previous_xs = null; // store the last position of the mouse
        var previous_ys = null; // store the last position of the mouse

        let trigger_mode = 'hover'; // store triggering mode
        let playing_mode = 'single'; // store playing mode
        var next_key_sound = null; // next sound to be linked to a key
        var right_click = false; // store if a right click happened

        var sound_keys = {}; // store the sounds associated to the keys
        var trackNb = 50; // total number of tracks
        var tracks = [audio_player]; // store all audios
        var analysers = []; // store all analysers
        var dataArrays = [] // store all dataArrays
        var next_tracks = []; // queue to store next track to be used
        var current_sound = []; // which sound is playing on each track
        var active_tracks = []; // which tracks are playing
        var radius_factors = [0.7, 1, 1.75];
        var bufferLength;

        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        var compressor = audioCtx.createDynamicsCompressor();
        var gainNode = audioCtx.createGain();
        compressor.connect(audioCtx.destination);
        gainNode.connect(compressor);
        gainNode.gain.value = 0.7;

        var clicked = false;
        var play_record_disable = true;
        var playing_record = false;
        var chunks = [];
        var dest = audioCtx.createMediaStreamDestination();
        var mediaRecorder = new MediaRecorder(dest.stream);
        compressor.connect(dest);
        const record_btn = document.getElementById("record");
        const play_record_btn = document.getElementById("play_record");
        const download_record_btn = document.getElementById("download_record");

        createTracks(); // create all the tracks
        draw();

        // Create all the tracks
        function createTracks() {
            const audio = audioCtx.createMediaElementSource(audio_player);
            audio.connect(gainNode);
            var analyser = audioCtx.createAnalyser();
            analyser.fftSize = 32;
            audio.connect(analyser).connect(gainNode);
            analysers.push(analyser);
            bufferLength = analysers[0].frequencyBinCount;
            var dataArray = new Uint8Array(bufferLength);
            dataArrays.push(dataArray);

            audio_player.addEventListener('pause', e => {
                var index_track = active_tracks.indexOf(0);
                active_tracks.splice(index_track, 1);
            });

            const record = audioCtx.createMediaElementSource(record_player);
            record.connect(gainNode);

            for (i = 1; i < trackNb; i++) {
                let track = new Audio();
                const audio = audioCtx.createMediaElementSource(track);
                var analyser = audioCtx.createAnalyser();
                analyser.fftSize = 32;
                var dataArray = new Uint8Array(bufferLength);
                audio.connect(analyser).connect(gainNode);

                track.addEventListener('pause', e => {
                    var index_track = active_tracks.indexOf(i);
                    active_tracks.splice(index_track, 1);
                });

                tracks.push(track);
                analysers.push(analyser);
                dataArrays.push(dataArray);
                next_tracks.push(i);
                current_sound.push(null);
            }
        }

        // Draw visualization
        function draw() {
            drawVisual = requestAnimationFrame(draw);
            ctxv.clearRect(0, 0, cv.width, cv.height);

            if (nbSounds > 0) {
                for (const i of active_tracks) {
                    analysers[i].getByteFrequencyData(dataArrays[i]);
                    var radius;
                    var x = positions[current_sound[i]][0];
                    var y = positions[current_sound[i]][1];

                    var r = Math.floor(map[current_sound[i]].color[0] / 1.25);
                    var g = Math.floor(map[current_sound[i]].color[1] / 1.25);
                    var b = Math.floor(map[current_sound[i]].color[2] / 1.25);
                    let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';

                    for (var j = 0; j < bufferLength - 1; j += 5) {
                        ctxv.beginPath();
                        ctxv.fillStyle = colorPoint;
                        ctxv.globalAlpha = 0.2;
                        radius = dataArrays[i][j] / 16 * radius_factors[j / 5];
                        ctxv.arc(x, y, radius, 0, 2 * Math.PI);
                        ctxv.fill();
                    }
                }
            }
        }

        // Record
        function record() {
            if (!clicked) {
                chunks = [];
                mediaRecorder.start();
                record_btn.textContent = "Stop recording";
                clicked = true;
            } else {
                mediaRecorder.requestData();
                mediaRecorder.stop();
                record_btn.textContent = "Record";
                clicked = false;
            }
        }

        // Push each chunk (blobs) in an array
        mediaRecorder.ondataavailable = function (evt) {
            chunks.push(evt.data);
        };

        // Make blob out of our blobs, and open it
        mediaRecorder.onstop = function (evt) {
            var blob = new Blob(chunks, { 'type': 'audio/wav' });
            // record_player.src = URL.createObjectURL(blob);
            var url = URL.createObjectURL(blob);
            record_player.src = url;
            document.getElementById("record_url").href = url;
            if (play_record_disable) {
                document.getElementById('play_record').disabled = false;
                document.getElementById('download_record').disabled = false;
                play_record_disable = false;
            }
        };

        function playRecord() {
            if (!playing_record) {
                playing_record = true;
                record_player.play();
                play_record_btn.textContent = "Pause";
            } else {
                playing_record = false;
                record_player.pause();
                play_record_btn.textContent = "Play record";
            }
        }

        record_player.addEventListener('pause', e => {
            if (playing_record) {
                playing_record = false;
                play_record_btn.textContent = "Play record";
            }
        })

        // Stop all sounds
        function stopAllSounds() {
            for (i = 0; i < tracks.length; i++) {
                if (!tracks[i].paused) {
                    tracks[i].pause();
                }
            }
            next_tracks = [];
            for (i = 1; i < trackNb; i++) {
                next_tracks.push(i);
            }
        }

        // Resize the canvas to fit the size of the window
        window.addEventListener('resize', e => {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
            ctx.clearRect(0, 0, c.width, c.height);
            recenter();
            createMap();
            cv.width = window.innerWidth;
            cv.height = window.innerHeight;
            ctxv.clearRect(0, 0, cv.width, cv.height);
        });

        // Prevent zooming in the page with the trackpad
        document.addEventListener("touchstart", function (e) {
            e.preventDefault();
        }, { passive: false });

        // Zoom in/out with the wheel
        cv.addEventListener('wheel', e => {
            e.preventDefault();
            var previous_scale = scale;

            if (e.deltaY < 0) {
                scale = scale * 1.1;
                centerX = centerX - (1 - 1 / 1.1) * (0.5 - e.offsetX / c.width) / previous_scale;
                centerY = centerY - (1 - 1 / 1.1) * (0.5 - e.offsetY / c.height) / previous_scale;
            } else {
                scale = scale / 1.1;
                centerX = centerX - (1 - 1.1) * (0.5 - e.offsetX / c.width) / previous_scale;
                centerY = centerY - (1 - 1.1) * (0.5 - e.offsetY / c.height) / previous_scale;
            }

            upDatePositions(scale, centerX, centerY);
            upDateGrid();
            ctx.clearRect(0, 0, c.width, c.height);
            createMap();
        });

        // Listen to mouse up event
        cv.addEventListener('mouseup', e => {
            down = false;
        });

        // Change to hover mode
        function hoverMode() {
            trigger_mode = 'hover';
        }

        // Change to click mode
        function clickMode() {
            trigger_mode = 'click';
        }

        // Change to single mode
        function singleMode() {
            playing_mode = 'single';
        }

        // Change to multiple mode
        function multipleMode() {
            playing_mode = 'multiple';
        }

        function nextTrack() {
            i = 0
            while (!tracks[next_tracks[i]].paused) {
                i++;
                if (i = next_tracks.length) {
                    i = 0;
                    tracks[next_tracks[0]].pause();
                    break;
                }
            }
            var track_id = next_tracks.splice(i, 1)[0];
            next_tracks.push(track_id);
            var index_track = active_tracks.indexOf(track_id);
            active_tracks.splice(index_track, 1);
            return track_id;
        }

        document.addEventListener('keydown', e => {
            if (e.shiftKey && e.code == 'KeyR') {
                record();
            } else if (e.code == 'Space') {
                e.preventDefault();
                if (!play_record_disable) {
                    playRecord();
                }
            } else {
                if (right_click) {
                    right_click = false;
                    sound_keys[e.code] = next_key_sound;
                }

                if (e.code in sound_keys) {
                    index = map[sound_keys[e.code]].file;
                    var files = audio_files.files;
                    var file = URL.createObjectURL(files[index]);
                    var track_id = nextTrack();
                    tracks[track_id].src = file;
                    current_sound[track_id] = sound_keys[e.code];
                    tracks[track_id].play();
                    active_tracks.push(track_id);
                    if (last_played != null) {
                        resetPoint(last_played);
                    }
                    drawCurrentPoint(sound_keys[e.code]);
                    last_played = sound_keys[e.code];
                    var text = document.getElementById("sound_name");
                    text.innerHTML = files[index].name;
                }
            }
        });

        cv.addEventListener('contextmenu', e => {
            e.preventDefault();

            xs = e.offsetX;
            ys = e.offsetY;
            var dist_min = 100;
            var i_min = null;

            for (let i = 0; i < nbSounds; i++) {
                var x = positions[i][0];
                var y = positions[i][1];
                var dx = xs - x;
                var dy = ys - y;
                var dist = dx * dx + dy * dy;
                if (dist < dist_min) {
                    dist_min = dist;
                    i_min = i;
                }
            }

            if (dist_min < pointRadius * pointRadius) {
                right_click = true;
                next_key_sound = i_min;
            }
        });

        // Listen to mouse down event 
        cv.addEventListener('mousedown', e => {
            down = true;
            previous_xs = e.offsetX;
            previous_ys = e.offsetY;

            // If shiftKey is pressed, select the sound by changing the color of its stroke
            if (e.shiftKey) {
                xs = e.offsetX;
                ys = e.offsetY;
                var dist_min = 100;
                var i_min = null;

                for (let i = 0; i < nbSounds; i++) {
                    var x = positions[i][0];
                    var y = positions[i][1];
                    var dx = xs - x;
                    var dy = ys - y;
                    var dist = dx * dx + dy * dy;
                    if (dist < dist_min) {
                        dist_min = dist;
                        i_min = i;
                    }
                }

                if (dist_min < pointRadius * pointRadius) {
                    if (selected.includes(i_min)) {
                        index_current = selected.indexOf(i_min);
                        selected.splice(index_current, 1);
                    } else {
                        selected.push(i_min);
                    }
                    ctx.clearRect(0, 0, c.width, c.height);
                    createMap();
                }
            }

            // Trigger the closest sound if it is close enough
            if (trigger_mode == 'click') {
                xs = e.offsetX;
                ys = e.offsetY;
                var dist_min = 100;
                var i_min = null;

                xgrid = Math.floor(xs / (2 * pointRadius));
                ygrid = Math.floor(ys / (2 * pointRadius));
                gridSounds = grid[xgrid][ygrid];

                gridSounds.forEach(i => {
                    var x = positions[i][0];
                    var y = positions[i][1];
                    var dx = xs - x;
                    var dy = ys - y;
                    var dist = dx * dx + dy * dy;
                    if (dist < dist_min) {
                        dist_min = dist;
                        i_min = i;
                    }
                });

                if (dist_min < pointRadius * pointRadius) {
                    if (last_played != null) {
                        resetPoint(last_played);
                    }
                    drawCurrentPoint(i_min);
                    index = map[i_min].file;
                    var files = audio_files.files;
                    var file = URL.createObjectURL(files[index]);
                    if (playing_mode == "single") {
                        if (!audio_player.paused) {
                            var index_track = active_tracks.indexOf(0);
                            active_tracks.splice(index_track, 1);
                        }
                        audio_player.src = file;
                        current_sound[0] = i_min;
                        audio_player.play();
                        active_tracks.push(0);
                    } else {
                        var track_id = nextTrack();
                        tracks[track_id].src = file;
                        current_sound[track_id] = i_min;
                        tracks[track_id].play();
                        active_tracks.push(track_id);
                    }
                    last_played = i_min;
                    var text = document.getElementById("sound_name");
                    text.innerHTML = files[index].name;

                }
            }
        });

        // Listen to mouse move event
        cv.addEventListener('mousemove', e => {

            // If the mouse button i down, move the map
            if (down) {
                centerX = centerX - (e.offsetX - previous_xs) / (scale * c.width);
                centerY = centerY - (e.offsetY - previous_ys) / (scale * c.height);
                previous_xs = e.offsetX;
                previous_ys = e.offsetY;
                upDatePositions(scale, centerX, centerY);
                upDateGrid();
                ctx.clearRect(0, 0, c.width, c.height);
                createMap();
            }

            // Trigger the closest sound if it is close enough
            else {
                let now = Date.now()
                if (now - last > sleep) {
                    if (trigger_mode == 'hover') {
                        xs = e.offsetX;
                        ys = e.offsetY;
                        var dist_min = 100;
                        var i_min = null;

                        for (let i = 0; i < nbSounds; i++) {
                            var x = positions[i][0];
                            var y = positions[i][1];
                            var dx = xs - x;
                            var dy = ys - y;
                            var dist = dx * dx + dy * dy;
                            if (dist < dist_min) {
                                dist_min = dist;
                                i_min = i;
                            }
                        }

                        if (dist_min < pointRadius * pointRadius) {
                            if (last_played == i_min) {
                                if (now - last_same > sleep_same) {
                                    index = map[i_min].file;
                                    var files = audio_files.files;
                                    var file = URL.createObjectURL(files[index]);
                                    if (playing_mode == "single") {
                                        if (!audio_player.paused) {
                                            var index_track = active_tracks.indexOf(0);
                                            active_tracks.splice(index_track, 1);
                                        }
                                        audio_player.src = file;
                                        current_sound[0] = i_min;
                                        audio_player.play();
                                        active_tracks.push(0);
                                    } else {
                                        var track_id = nextTrack();
                                        tracks[track_id].src = file;
                                        current_sound[track_id] = i_min;
                                        tracks[track_id].play();
                                        active_tracks.push(track_id);
                                    }
                                    last = Date.now();
                                    last_same = Date.now();
                                }
                            } else {
                                if (last_played != null) {
                                    resetPoint(last_played);
                                }
                                drawCurrentPoint(i_min);
                                index = map[i_min].file;
                                var files = audio_files.files;
                                var file = URL.createObjectURL(files[index]);
                                if (playing_mode == "single") {
                                    if (!audio_player.paused) {
                                        var index_track = active_tracks.indexOf(0);
                                        active_tracks.splice(index_track, 1);
                                    }
                                    audio_player.src = file;
                                    current_sound[0] = i_min;
                                    audio_player.play();
                                    active_tracks.push(0);
                                } else {
                                    var track_id = nextTrack();
                                    tracks[track_id].src = file;
                                    current_sound[track_id] = i_min;
                                    tracks[track_id].play();
                                    active_tracks.push(track_id);
                                }
                                last = Date.now();
                                last_same = Date.now();
                                last_played = i_min;
                                var text = document.getElementById("sound_name");
                                text.innerHTML = files[index].name;
                            }
                        }
                    }
                }
            }
        });

        // Recenter the map
        function recenter() {
            scale = 1;
            centerX = 0.5;
            centerY = 0.5;

            upDatePositions(scale, centerX, centerY);
            upDateGrid();
            ctx.clearRect(0, 0, c.width, c.height);
            createMap();

        }

        // Update the position of the points on the map according to the scale and center
        function upDatePositions(scale, centerX, centerY) {
            positions = [];
            for (let i = 0; i < nbSounds; i++) {
                offsetX = c.width * (0.5 - scale * centerX);
                offsetY = c.height * (0.5 - scale * centerY);
                var x = (0.7 * map[i].point[0] + 0.15) * c.width * scale + offsetX;
                var y = (0.7 * map[i].point[1] + 0.15) * c.height * scale + offsetY;
                positions.push([x, y]);
            }
        }

        // Add a point on the canvas
        function addPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25);
            var g = Math.floor(map[i].color[1] / 1.25);
            var b = Math.floor(map[i].color[2] / 1.25);
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];
            ctx.beginPath();
            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = background_color;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Reset the point after playing
        function resetPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25);
            var g = Math.floor(map[i].color[1] / 1.25);
            var b = Math.floor(map[i].color[2] / 1.25);
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];

            ctx.beginPath();

            ctx.fillStyle = background_color;
            ctx.strokeStyle = background_color;
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = background_color;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Highlight current point
        function drawCurrentPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25) + 40;
            var g = Math.floor(map[i].color[1] / 1.25) + 40;
            var b = Math.floor(map[i].color[2] / 1.25) + 40;
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];
            ctx.beginPath();
            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = colorPoint;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Initiate the grid
        function initiateGrid() {
            var gridWidth = Math.floor(c.width / (2 * pointRadius));
            var gridHeight = Math.floor(c.height / (2 * pointRadius));
            grid = new Array(gridWidth);
            for (let i = 0; i < gridWidth; i++) {
                grid[i] = new Array(gridHeight);
                for (let j = 0; j < gridHeight; j++) {
                    grid[i][j] = [];
                }
            }
        }

        // Update the grid
        function upDateGrid() {
            var gridWidth = Math.floor(c.width / (2 * pointRadius));
            var gridHeight = Math.floor(c.height / (2 * pointRadius));
            grid = new Array(gridWidth);
            for (let i = 0; i < gridWidth; i++) {
                grid[i] = new Array(gridHeight);
                for (let j = 0; j < gridHeight; j++) {
                    grid[i][j] = [];
                }
            }

            for (let i = 0; i < nbSounds; i++) {
                var xgrid = Math.floor(positions[i][0] / (2 * pointRadius));
                var ygrid = Math.floor(positions[i][1] / (2 * pointRadius));
                if (xgrid >= 0 && ygrid >= 0 && xgrid < gridWidth && ygrid < gridHeight) {
                    if (xgrid >= 1 && ygrid >= 1 && xgrid < gridWidth - 1 && ygrid < gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                grid[x][y].push(i);
                            }
                        }
                    } else if (xgrid == 0 && ygrid >= 1 && ygrid < gridHeight - 1) {
                        for (let x = xgrid; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == gridWidth - 1 && ygrid >= 1 && ygrid < gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid; x++) {
                            for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == 0) {
                        for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                            for (let y = ygrid; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == 0 && ygrid == 0) {
                        for (let x = xgrid; x <= xgrid + 1; x++) {
                            for (let y = ygrid; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == gridWidth - 1 && ygrid == 0) {
                        for (let x = xgrid - 1; x <= xgrid; x++) {
                            for (let y = ygrid; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == 0 && ygrid == gridHeight - 1) {
                        for (let x = xgrid; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == gridWidth - 1 && ygrid == gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid; x++) {
                            for (let y = ygrid - 1; y <= ygrid; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    }
                }
            }
        }

        // Draw the map on the canvas
        function createMap() {
            for (let i = 0; i < nbSounds; i++) {
                addPoint(i)
            }
        }

        // Call the API to compute the map
        function computeMap() {
            resetMap();
            var totalfiles = document.getElementById('audio_files').files.length;
            const text = document.getElementById("text_compute");

            if (totalfiles > 0) {
                text.innerHTML = "Computing...";

                var formData = new FormData();

                // Read selected files
                for (var index = 0; index < totalfiles; index++) {
                    formData.append("files[]", document.getElementById('audio_files').files[index]);
                }

                fetch('http://localhost:5000/api', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.json())
                    .then(sound_map => {
                        map = JSON.parse(sound_map['sound_map']);
                        for (sound in map) {
                            nbSounds++;
                        };
                        recenter();
                        createMap();
                        text.innerHTML = "";
                    })
            } else {
                text.innerHTML = "No file uploaded !";
            }
        }

        // Reset the map
        function resetMap() {
            ctx.clearRect(0, 0, c.width, c.height);
            nbSounds = 0;
            last_played = null;
        }

    </script>
</body>

</html>