<!DOCTYPE html>

<head>
    <link rel="shortcut icon" href="static/attachment/treeIcon.png">
    <link rel="stylesheet" href="static/prod.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>

<body>
    <div class="interface">
        <header class="elementLeft">
            <a class="logo" href="http://localhost:5000">Musique Normale</a>
            <p class="sublogo">Digital Sound, Musical Practice</p>
        </header>

        <div class="subinterface">
            <input class="button" type="file" name="audio_files" id="audio_files" webkitdirectory multiple>

            <input class="button" type="button" value="Compute map" id="compute" onclick="computeMap()">
            <a id="text_compute"></a>

            <input class="button" type="button" value="Recenter" id="recenter" onclick="recenter()">

            <div class="containerRadio">
                <p><b>Triggering mode</b></p>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="hover" name="trigger_mode" value="hover"
                        onclick="hoverMode()" checked>
                    <label class="radiobuttonlabel" for="hover">Hover</label>
                </div>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="click" name="trigger_mode" value="click"
                        onclick="clickMode()">
                    <label class="radiobuttonlabel" for="click">Click</label>
                </div>

                <p><b>Playing mode</b></p>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="single" name="playing_mode" value="single"
                        onclick="singleMode()" checked>
                    <label class="radiobuttonlabel" for="single">Single</label>
                </div>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="multiple" name="playing_mode" value="multiple"
                        onclick="multipleMode()">
                    <label class="radiobuttonlabel" for="multiple">Multiple</label>
                </div>
            </div>

            <input class="button" type="button" value="Stop all sounds" id="stop_all_sounds" onclick="stopAllSounds()">

            <p id="sound_name"></p>
        </div>
    </div>
    <audio id="audio_player"></audio>

    <canvas id="myCanvas" class="myCanvas">
    </canvas>

    <script>

        // Init
        var background_color = 'rgb(239,239,239)'; // background color
        var c = document.getElementById('myCanvas');
        var ctx = c.getContext('2d');
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        ctx.fillStyle = background_color;
        ctx.fillRect(0, 0, c.width, c.height);
        var map = {}; // store the map
        var nbSounds = 0; // total number of sounds in the map
        var positions = []; // position of the sounds on the canvas
        var scale = 1; // change scale to zoom in or out (event wheel)
        var centerX = 0.5; // x coordonate of the center (in the original map referential)
        var centerY = 0.5; // y coordonate of the center (in the original map referential)
        const sleep = 150; // minimum time between 2 sounds triggering
        const sleep_same = 500; // minimum time between 2 triggering of the same sound
        let last = Date.now(); // last time a sound was played
        let last_same = Date.now(); // last time the sound we want to replay has been played
        var last_played = null; // last sound that has been played
        var selected = []; // list of selected sounds
        var pointRadius = 5; // radius of the points
        var grid = null; // store the grid
        initiateGrid(); // initiate the grid
        var down = false; // store the state of the mouse button
        var previous_xs = null; // store the last position of the mouse
        var previous_ys = null; // store the last position of the mouse
        var playing_sounds = [audio_player]; // store all audios
        let trigger_mode = 'hover'; // store triggering mode
        let playing_mode = 'single'; // store playing mode
        var next_key_sound = null; // next sound to be linked to a key
        var right_click = false; // store if a right click happened
        var sound_keys = {}; // store the sounds associated to the keys

        // Stop all sounds
        function stopAllSounds() {
            for (i = 0; i < playing_sounds.length; i++) {
                if (!playing_sounds[i].pause()) {
                    playing_sounds[i].pause();
                }
            }
            playing_sounds = [audio_player];
        }

        // Resize the canvas to fit the size of the window
        window.addEventListener('resize', e => {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
            ctx.fillStyle = background_color;
            ctx.fillRect(0, 0, c.width, c.height);
            recenter();
            createMap();
        });

        // Prevent zooming in the page with the trackpad
        document.addEventListener("touchstart", function (e) {
            e.preventDefault();
        }, { passive: false });

        // Zoom in/out with the wheel
        c.addEventListener('wheel', e => {
            e.preventDefault();
            var previous_scale = scale;

            if (e.deltaY < 0) {
                scale = scale * 1.1;
                centerX = centerX - (1 - 1 / 1.1) * (0.5 - e.offsetX / c.width) / previous_scale;
                centerY = centerY - (1 - 1 / 1.1) * (0.5 - e.offsetY / c.height) / previous_scale;
            } else {
                scale = scale / 1.1;
                centerX = centerX - (1 - 1.1) * (0.5 - e.offsetX / c.width) / previous_scale;
                centerY = centerY - (1 - 1.1) * (0.5 - e.offsetY / c.height) / previous_scale;
            }

            upDatePositions(scale, centerX, centerY);
            upDateGrid();
            ctx.fillStyle = background_color;
            ctx.fillRect(0, 0, c.width, c.height);
            createMap();
        });

        // Listen to mouse up event
        c.addEventListener('mouseup', e => {
            down = false;
        });

        // Change to hover mode
        function hoverMode() {
            trigger_mode = 'hover';
        }

        // Change to click mode
        function clickMode() {
            trigger_mode = 'click';
        }

        // Change to single mode
        function singleMode() {
            playing_mode = 'single';
        }

        // Change to multiple mode
        function multipleMode() {
            playing_mode = 'multiple';
        }

        document.addEventListener('keydown', e => {
            if (right_click) {
                right_click = false;
                sound_keys[e.code] = next_key_sound;
            }

            if (e.code in sound_keys) {
                index = map[sound_keys[e.code]].file;
                var files = audio_files.files;
                var file = URL.createObjectURL(files[index]);
                var snd = new Audio(file);
                snd.play();
                playing_sounds.push(snd);
                if (last_played != null) {
                    resetPoint(last_played);
                }
                drawCurrentPoint(sound_keys[e.code]);
                last_played = sound_keys[e.code];
                var text = document.getElementById("sound_name");
                text.innerHTML = files[index].name;
            }
        });

        c.addEventListener('contextmenu', e => {
            e.preventDefault();

            xs = e.offsetX;
            ys = e.offsetY;
            var dist_min = 100;
            var i_min = null;

            for (let i = 0; i < nbSounds; i++) {
                var x = positions[i][0];
                var y = positions[i][1];
                var dx = xs - x;
                var dy = ys - y;
                var dist = dx * dx + dy * dy;
                if (dist < dist_min) {
                    dist_min = dist;
                    i_min = i;
                }
            }

            if (dist_min < pointRadius * pointRadius) {
                right_click = true;
                next_key_sound = i_min;
            }
        });

        // Listen to mouse down event 
        c.addEventListener('mousedown', e => {
            down = true;
            previous_xs = e.offsetX;
            previous_ys = e.offsetY;

            // If shiftKey is pressed, select the sound by changing the color of its stroke
            if (e.shiftKey) {
                xs = e.offsetX;
                ys = e.offsetY;
                var dist_min = 100;
                var i_min = null;

                for (let i = 0; i < nbSounds; i++) {
                    var x = positions[i][0];
                    var y = positions[i][1];
                    var dx = xs - x;
                    var dy = ys - y;
                    var dist = dx * dx + dy * dy;
                    if (dist < dist_min) {
                        dist_min = dist;
                        i_min = i;
                    }
                }

                if (dist_min < pointRadius * pointRadius) {
                    if (selected.includes(i_min)) {
                        index_current = selected.indexOf(i_min);
                        selected.splice(index_current, 1);
                    } else {
                        selected.push(i_min);
                    }
                    ctx.fillStyle = background_color;
                    ctx.fillRect(0, 0, c.width, c.height);
                    createMap();
                }
            }

            // Trigger the closest sound if it is close enough
            if (trigger_mode == 'click') {
                xs = e.offsetX;
                ys = e.offsetY;
                var dist_min = 100;
                var i_min = null;

                xgrid = Math.floor(xs / (2 * pointRadius));
                ygrid = Math.floor(ys / (2 * pointRadius));
                gridSounds = grid[xgrid][ygrid];

                gridSounds.forEach(i => {
                    var x = positions[i][0];
                    var y = positions[i][1];
                    var dx = xs - x;
                    var dy = ys - y;
                    var dist = dx * dx + dy * dy;
                    if (dist < dist_min) {
                        dist_min = dist;
                        i_min = i;
                    }
                });

                if (dist_min < pointRadius * pointRadius) {
                    if (last_played != null) {
                        resetPoint(last_played);
                    }
                    drawCurrentPoint(i_min);
                    index = map[i_min].file;
                    var files = audio_files.files;
                    var file = URL.createObjectURL(files[index]);
                    if (playing_mode == "single") {
                        audio_player.src = file;
                        audio_player.play();
                    } else {
                        var snd = new Audio(file);
                        snd.play();
                        playing_sounds.push(snd);
                    }
                    last_played = i_min;
                    var text = document.getElementById("sound_name");
                    text.innerHTML = files[index].name;

                }
            }
        });

        // Listen to mouse move event
        c.addEventListener('mousemove', e => {

            // If the mouse button i down, move the map
            if (down) {
                centerX = centerX - (e.offsetX - previous_xs) / (scale * c.width);
                centerY = centerY - (e.offsetY - previous_ys) / (scale * c.height);
                previous_xs = e.offsetX;
                previous_ys = e.offsetY;
                upDatePositions(scale, centerX, centerY);
                upDateGrid();
                ctx.fillStyle = background_color;
                ctx.fillRect(0, 0, c.width, c.height);
                createMap();
            }

            // Trigger the closest sound if it is close enough
            else {
                let now = Date.now()
                if (now - last > sleep) {
                    if (trigger_mode == 'hover') {
                        xs = e.offsetX;
                        ys = e.offsetY;
                        var dist_min = 100;
                        var i_min = null;

                        for (let i = 0; i < nbSounds; i++) {
                            var x = positions[i][0];
                            var y = positions[i][1];
                            var dx = xs - x;
                            var dy = ys - y;
                            var dist = dx * dx + dy * dy;
                            if (dist < dist_min) {
                                dist_min = dist;
                                i_min = i;
                            }
                        }

                        if (dist_min < pointRadius * pointRadius) {
                            if (last_played == i_min) {
                                if (now - last_same > sleep_same) {
                                    index = map[i_min].file;
                                    var files = audio_files.files;
                                    var file = URL.createObjectURL(files[index]);
                                    audio_player.src = file;
                                    audio_player.play();
                                    last = Date.now();
                                    last_same = Date.now();
                                }
                            } else {
                                if (last_played != null) {
                                    resetPoint(last_played);
                                }
                                drawCurrentPoint(i_min);
                                index = map[i_min].file;
                                var files = audio_files.files;
                                var file = URL.createObjectURL(files[index]);
                                if (playing_mode == "single") {
                                    audio_player.src = file;
                                    audio_player.play();
                                } else {
                                    var snd = new Audio(file);
                                    snd.play();
                                    playing_sounds.push(snd);
                                }
                                last = Date.now();
                                last_same = Date.now();
                                last_played = i_min;
                                var text = document.getElementById("sound_name");
                                text.innerHTML = files[index].name;
                            }
                        }
                    }
                }
            }
        });

        // Recenter the map
        function recenter() {
            scale = 1;
            centerX = 0.5;
            centerY = 0.5;

            upDatePositions(scale, centerX, centerY);
            upDateGrid();
            ctx.fillStyle = background_color;
            ctx.fillRect(0, 0, c.width, c.height);
            createMap();

        }

        // Update the position of the points on the map according to the scale and center
        function upDatePositions(scale, centerX, centerY) {
            positions = [];
            for (let i = 0; i < nbSounds; i++) {
                offsetX = c.width * (0.5 - scale * centerX);
                offsetY = c.height * (0.5 - scale * centerY);
                var x = (0.7 * map[i].point[0] + 0.15) * c.width * scale + offsetX;
                var y = (0.7 * map[i].point[1] + 0.15) * c.height * scale + offsetY;
                positions.push([x, y]);
            }
        }

        // Add a point on the canvas
        function addPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25);
            var g = Math.floor(map[i].color[1] / 1.25);
            var b = Math.floor(map[i].color[2] / 1.25);
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];
            ctx.beginPath();
            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = background_color;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Reset the point after playing
        function resetPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25);
            var g = Math.floor(map[i].color[1] / 1.25);
            var b = Math.floor(map[i].color[2] / 1.25);
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];

            ctx.beginPath();

            ctx.fillStyle = background_color;
            ctx.strokeStyle = background_color;
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = background_color;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Highlight current point
        function drawCurrentPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25) + 40;
            var g = Math.floor(map[i].color[1] / 1.25) + 40;
            var b = Math.floor(map[i].color[2] / 1.25) + 40;
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];
            ctx.beginPath();
            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = colorPoint;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Initiate the grid
        function initiateGrid() {
            var gridWidth = Math.floor(c.width / (2 * pointRadius));
            var gridHeight = Math.floor(c.height / (2 * pointRadius));
            grid = new Array(gridWidth);
            for (let i = 0; i < gridWidth; i++) {
                grid[i] = new Array(gridHeight);
                for (let j = 0; j < gridHeight; j++) {
                    grid[i][j] = [];
                }
            }
        }

        // Update the grid
        function upDateGrid() {
            var gridWidth = Math.floor(c.width / (2 * pointRadius));
            var gridHeight = Math.floor(c.height / (2 * pointRadius));
            grid = new Array(gridWidth);
            for (let i = 0; i < gridWidth; i++) {
                grid[i] = new Array(gridHeight);
                for (let j = 0; j < gridHeight; j++) {
                    grid[i][j] = [];
                }
            }

            for (let i = 0; i < nbSounds; i++) {
                var xgrid = Math.floor(positions[i][0] / (2 * pointRadius));
                var ygrid = Math.floor(positions[i][1] / (2 * pointRadius));
                if (xgrid >= 0 && ygrid >= 0 && xgrid < gridWidth && ygrid < gridHeight) {
                    if (xgrid >= 1 && ygrid >= 1 && xgrid < gridWidth - 1 && ygrid < gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                grid[x][y].push(i);
                            }
                        }
                    } else if (xgrid == 0 && ygrid >= 1 && ygrid < gridHeight - 1) {
                        for (let x = xgrid; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == gridWidth - 1 && ygrid >= 1 && ygrid < gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid; x++) {
                            for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == 0) {
                        for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                            for (let y = ygrid; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == 0 && ygrid == 0) {
                        for (let x = xgrid; x <= xgrid + 1; x++) {
                            for (let y = ygrid; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == gridWidth - 1 && ygrid == 0) {
                        for (let x = xgrid - 1; x <= xgrid; x++) {
                            for (let y = ygrid; y <= ygrid + 1; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == 0 && ygrid == gridHeight - 1) {
                        for (let x = xgrid; x <= xgrid + 1; x++) {
                            for (let y = ygrid - 1; y <= ygrid; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    } else if (xgrid == gridWidth - 1 && ygrid == gridHeight - 1) {
                        for (let x = xgrid - 1; x <= xgrid; x++) {
                            for (let y = ygrid - 1; y <= ygrid; y++) {
                                grid[x][y].push(i)
                            }
                        }
                    }
                }
            }
        }

        // Draw the map on the canvas
        function createMap() {
            for (let i = 0; i < nbSounds; i++) {
                addPoint(i)
            }
        }

        // Call the API to compute the map
        function computeMap() {
            resetMap();
            var totalfiles = document.getElementById('audio_files').files.length;
            const text = document.getElementById("text_compute");

            if (totalfiles > 0) {
                text.innerHTML = "Computing...";

                var formData = new FormData();

                // Read selected files
                for (var index = 0; index < totalfiles; index++) {
                    formData.append("files[]", document.getElementById('audio_files').files[index]);
                }

                fetch('http://localhost:5000/api', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.json())
                    .then(sound_map => {
                        map = JSON.parse(sound_map['sound_map']);
                        for (sound in map) {
                            nbSounds++
                        };
                        recenter();
                        createMap();
                        text.innerHTML = "";
                    })
            } else {
                text.innerHTML = "No file uploaded !";
            }
        }

        // Reset the map
        function resetMap() {
            ctx.fillStyle = background_color;
            ctx.fillRect(0, 0, c.width, c.height);
            nbSounds = 0;
        }

    </script>
</body>

</html>