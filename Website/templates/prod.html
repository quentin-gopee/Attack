<!DOCTYPE html>

<head>
    <link rel="shortcut icon" href="static/attachment/treeIcon.png">
    <link rel="stylesheet" href="static/prod.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>

<body>
    <div class="interface">
        <header class="elementLeft">
            <a class="logo" href="http://localhost:5000">Attac:k!</a>
            <p class="sublogo">Stop Scrolling, Start Playing.</p>
        </header>

        <div class="subinterface">
            <input class="button" type="file" value="Load samples" name="audio_files" id="audio_files" webkitdirectory multiple>

            <input class="button" type="button" value="Compute map" id="compute" onclick="computeMap()">
            <a id="text_compute"></a>

            <input class="button" type="button" value="Recenter" id="recenter" onclick="recenter()">

            <div class="containerRadio">
                <p><b>Playing mode</b></p>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="single" name="playing_mode" value="single"
                        onclick="singleMode()" checked>
                    <label class="radiobuttonlabel" for="single">Single</label>
                </div>
                <div class="RadioButtonContainer">
                    <input class="radiobutton" type="radio" id="multiple" name="playing_mode" value="multiple"
                        onclick="multipleMode()">
                    <label class="radiobuttonlabel" for="multiple">Multiple</label>
                </div>
            </div>

            <input class="button" type="button" value="Stop all sounds" id="stop_all_sounds" onclick="stopAllSounds()">

            <button class="button" id="record" onclick="record()">Record</button>
            <button class="button" id="play_record" disabled onclick="playRecord()">Play record</button>

            <a href="" download="Futur tube" id="record_url">
                <button class="button" id="download_record" disabled>Download record</button>
            </a>

            <p id="sound_name"></p>
        </div>
    </div>

    <!-- <div class="range">
        <input type="range" id="time bt 2 snds" name="time bt 2 snds" min="0" max="500" value="50" step="10">
        <label for="time bt 2 snds" id="time bt 2 snds label">Time bt 2 snds : 50</label>

        <input type="range" id="gain" name="gain" min="0" max="2" value="0.7" step="0.01">
        <label for="gain" id="gain label">Gain : 0.7</label>

        <input type="range" id="treshold" name="treshold" min="-100" max="0" value="-24" step="1">
        <label for="treshold" id="treshold label">Compressor treshold : -24</label>
    </div> -->

    <div class="search">
        <input type=text" placeholder="Type a keyword" id="search_bar">
        <button id="search" onclick="search()">Search</button>
        <button id="delete filter" onclick="deleteFilter()">Delete filter</button>
    </div>

    <nav class="menu elementLeft">
        <ul>
            <li>
                <a class="nav" href="http://localhost:5000/prod"><b>prod</b></a>
            </li>
            <li>
                <a class="nav" href="http://localhost:5000/help">help</a>
            </li>
        </ul>
    </nav>

    <audio id="audio_player"></audio>
    <audio id="record_player"></audio>

    <canvas id="mapCanvas" class="mapCanvas">
    </canvas>

    <canvas id="visuCanvas" class="visuCanvas">
    </canvas>

    <script>

        // Init
        var background_color = 'rgb(239,239,239)'; // background color
        var c = document.getElementById('mapCanvas');
        var ctx = c.getContext('2d');
        c.width = window.innerWidth;
        c.height = window.innerHeight;

        var cv = document.getElementById('visuCanvas');
        var ctxv = cv.getContext('2d');
        cv.width = window.innerWidth;
        cv.height = window.innerHeight;

        var map = {}; // store the map
        var nbSounds = 0; // total number of sounds in the map
        var positions = []; // position of the sounds on the canvas
        var scale = 1; // change scale to zoom in or out (event wheel)
        var centerX = 0.5; // x coordonate of the center (in the original map referential)
        var centerY = 0.5; // y coordonate of the center (in the original map referential)
        var selected = []; // list of selected sounds
        var pointRadius = 5; // radius of the points
        var grid = null; // store the grid
        initiateGrid(); // initiate the grid

        var sleep = 50; // minimum time between 2 sounds triggering
        let last = Date.now(); // last time a sound was played
        let last_same = Date.now(); // last time the sound we want to replay has been played
        var last_played = null; // last sound that has been played
        var inpoint = false; // true if the mouse is on a point

        var down = false; // store the state of the mouse button
        var previous_xs = null; // store the last position of the mouse
        var previous_ys = null; // store the last position of the mouse

        let trigger_mode = 'hover'; // store triggering mode
        let playing_mode = 'single'; // store playing mode
        var next_key_sound = null; // next sound to be linked to a key
        var right_click = false; // store if a right click happened

        var sound_keys = {}; // store the sounds associated to the keys
        var keys_state = {}; // store the state of each key
        var next_sounds = [] // store the next sounds to play after hitting a key
        var trackNb = 100; // total number of tracks
        var tracks = [audio_player]; // store all audios
        var analysers = []; // store all analysers
        var dataArrays = [] // store all dataArrays
        var next_tracks = []; // queue to store next track to be used
        var current_sound = []; // which sound is playing on each track
        var active_tracks = []; // which tracks are playing
        var radius_factors = [0.7, 1.5, 1.5, 1.5];
        var freq = [0, 3, 7, 10]
        var bufferLength;

        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        var compressor = audioCtx.createDynamicsCompressor();
        var gainNode = audioCtx.createGain();
        compressor.connect(audioCtx.destination);
        gainNode.connect(compressor);
        gainNode.gain.value = 0.7;

        var clicked = false;
        var play_record_disable = true;
        var playing_record = false;
        var chunks = [];
        var dest = audioCtx.createMediaStreamDestination();
        var mediaRecorder = new MediaRecorder(dest.stream);
        compressor.connect(dest);
        const record_btn = document.getElementById("record");
        const play_record_btn = document.getElementById("play_record");
        const download_record_btn = document.getElementById("download_record");

        var filtered = [] // Output sounds of the search
        var filter_active = false // store if the search filter is active
        const search_bar = document.getElementById("search_bar");

        createTracks(); // create all the tracks
        initRadioBtn();
        draw();
        keyPlay();

        // // Temp
        // const slide2 = document.getElementById("time bt 2 snds");
        // const slidegain = document.getElementById("gain");
        // const slidetreshold = document.getElementById("treshold");

        // initSliders();

        // slide2.addEventListener('input', e => {
        //     sleep = slide2.value;
        //     var text = document.getElementById("time bt 2 snds label");
        //     text.innerHTML = "Time bt 2 snds : " + sleep;
        // });

        // slidegain.addEventListener('input', e => {
        //     gainNode.gain.value = slidegain.value;
        //     var text = document.getElementById("gain label");
        //     text.innerHTML = "Gain : " + slidegain.value;
        // });

        // slidetreshold.addEventListener('input', e => {
        //     compressor.threshold.value = slidetreshold.value;
        //     var text = document.getElementById("treshold label");
        //     text.innerHTML = "Compressor treshold : " + slidetreshold.value;
        // });

        // function initSliders() {
        //     sleep = slide2.value;
        //     var text = document.getElementById("time bt 2 snds label");
        //     text.innerHTML = "Time bt 2 snds : " + sleep;

        //     gainNode.gain.value = slidegain.value;
        //     text = document.getElementById("gain label");
        //     text.innerHTML = "Gain : " + slidegain.value;

        //     compressor.threshold.value = slidetreshold.value;
        //     text = document.getElementById("treshold label");
        //     text.innerHTML = "Compressor treshold : " + slidetreshold.value;
        // }

        // Create all the tracks
        function createTracks() {
            const audio = audioCtx.createMediaElementSource(audio_player);
            audio.connect(gainNode);
            var analyser = audioCtx.createAnalyser();
            analyser.fftSize = 32;
            audio.connect(analyser).connect(gainNode);
            analysers.push(analyser);
            bufferLength = analysers[0].frequencyBinCount;
            var dataArray = new Uint8Array(bufferLength);
            dataArrays.push(dataArray);

            audio_player.addEventListener('pause', e => {
                var index_track = active_tracks.indexOf(0);
                active_tracks.splice(index_track, 1);
            });

            const record = audioCtx.createMediaElementSource(record_player);
            record.connect(gainNode);

            for (var i = 1; i < trackNb; i++) {
                let track = new Audio();
                const audio = audioCtx.createMediaElementSource(track);
                var analyser = audioCtx.createAnalyser();
                analyser.fftSize = 32;
                var dataArray = new Uint8Array(bufferLength);
                audio.connect(analyser).connect(gainNode);

                track.addEventListener('pause', e => {
                    var tracknb = tracks.indexOf(track);
                    var index_track = active_tracks.indexOf(tracknb);
                    var track_deleted = active_tracks.splice(index_track, 1);
                });

                tracks.push(track);
                analysers.push(analyser);
                dataArrays.push(dataArray);
                next_tracks.push(i);
                current_sound.push(null);
            }
        }

        // Draw visualization
        function draw() {
            drawVisual = requestAnimationFrame(draw);
            ctxv.clearRect(0, 0, cv.width, cv.height);

            if (nbSounds > 0) {
                for (const i of active_tracks) {
                    analysers[i].getByteFrequencyData(dataArrays[i]);
                    var radius;
                    var x = positions[current_sound[i]][0];
                    var y = positions[current_sound[i]][1];

                    var r = Math.floor(map[current_sound[i]].color[0] / 1.25);
                    var g = Math.floor(map[current_sound[i]].color[1] / 1.25);
                    var b = Math.floor(map[current_sound[i]].color[2] / 1.25);
                    let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';

                    for (var j = 0; j < 4; j++) {
                        ctxv.beginPath();
                        ctxv.fillStyle = colorPoint;
                        ctxv.globalAlpha = 0.2;
                        radius = dataArrays[i][freq[j]] / 16 * radius_factors[j];
                        ctxv.arc(x, y, radius, 0, 2 * Math.PI);
                        ctxv.fill();
                    }
                }
            }
        }

        // On certain navigators radio button are not reseted
        function initRadioBtn() {
            const radioPlayingMode = document.querySelectorAll('input[name="playing_mode"]');
            for (const rb of radioPlayingMode) {
                if (rb.checked) {
                    playing_mode = rb.value;
                    break;
                }
            }
        }

        // Search
        function search() {
            var keyword = search_bar.value;
            filtered = [];
            for (var i = 0; i < nbSounds; i++) {
                if (map[i].name.toLowerCase().includes(keyword)) {
                    filtered.push(i);
                }
            }
            filter_active = true;
            last_played = null;
            upDateGrid();
            ctx.clearRect(0, 0, c.width, c.height);
            createMap();
        }

        search_bar.addEventListener('keydown', e => {
            if (e.code == 'Enter') {
                search();
            }
        });

        // Delete filter
        function deleteFilter() {
            filter_active = false;
            upDateGrid();
            ctx.clearRect(0, 0, c.width, c.height);
            createMap();
        }

        // Record
        function record() {
            if (!clicked) {
                chunks = [];
                mediaRecorder.start();
                record_btn.textContent = "Stop recording";
                clicked = true;
            } else {
                mediaRecorder.requestData();
                mediaRecorder.stop();
                record_btn.textContent = "Record";
                clicked = false;
            }
        }

        // Push each chunk (blobs) in an array
        mediaRecorder.ondataavailable = function (evt) {
            chunks.push(evt.data);
        };

        // Make blob out of our blobs, and open it
        mediaRecorder.onstop = function (evt) {
            var blob = new Blob(chunks, { 'type': 'audio/wav' });
            // record_player.src = URL.createObjectURL(blob);
            var url = URL.createObjectURL(blob);
            record_player.src = url;
            document.getElementById("record_url").href = url;
            if (play_record_disable) {
                document.getElementById('play_record').disabled = false;
                document.getElementById('download_record').disabled = false;
                play_record_disable = false;
            }
        };

        function playRecord() {
            if (!playing_record) {
                playing_record = true;
                record_player.play();
                play_record_btn.textContent = "Pause";
            } else {
                playing_record = false;
                record_player.pause();
                play_record_btn.textContent = "Play record";
            }
        }

        record_player.addEventListener('pause', e => {
            if (playing_record) {
                playing_record = false;
                play_record_btn.textContent = "Play record";
            }
        })

        // Stop all sounds
        function stopAllSounds() {
            for (var i = 0; i < tracks.length; i++) {
                if (!tracks[i].paused) {
                    tracks[i].pause();
                }
            }
            next_tracks = [];
            for (var i = 1; i < trackNb; i++) {
                next_tracks.push(i);
            }
        }

        // Resize the canvas to fit the size of the window
        window.addEventListener('resize', e => {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
            ctx.clearRect(0, 0, c.width, c.height);
            recenter();
            createMap();
            cv.width = window.innerWidth;
            cv.height = window.innerHeight;
            ctxv.clearRect(0, 0, cv.width, cv.height);
        });

        // Prevent zooming in the page with the trackpad
        document.addEventListener("touchstart", function (e) {
            e.preventDefault();
        }, { passive: false });

        // Zoom in/out with the wheel
        cv.addEventListener('wheel', e => {
            e.preventDefault();
            var previous_scale = scale;

            if (e.deltaY < 0) {
                scale = scale * 1.1;
                centerX = centerX - (1 - 1 / 1.1) * (0.5 - e.offsetX / c.width) / previous_scale;
                centerY = centerY - (1 - 1 / 1.1) * (0.5 - e.offsetY / c.height) / previous_scale;
            } else {
                scale = scale / 1.1;
                centerX = centerX - (1 - 1.1) * (0.5 - e.offsetX / c.width) / previous_scale;
                centerY = centerY - (1 - 1.1) * (0.5 - e.offsetY / c.height) / previous_scale;
            }

            upDatePositions(scale, centerX, centerY);
            upDateGrid();
            ctx.clearRect(0, 0, c.width, c.height);
            createMap();
        });

        // Listen to mouse up event
        cv.addEventListener('mouseup', e => {
            down = false;
        });

        // Change to single mode
        function singleMode() {
            playing_mode = 'single';
        }

        // Change to multiple mode
        function multipleMode() {
            playing_mode = 'multiple';
        }

        function nextTrack() {
            var i = 0;
            while (!tracks[next_tracks[i]].paused) {
                i++;
                if (i = next_tracks.length) {
                    i = 0;
                    tracks[next_tracks[0]].pause();
                    var index_track = active_tracks.indexOf(next_tracks[0]);
                    active_tracks.splice(index_track, 1);
                    break;
                }
            }
            var track_id = next_tracks.splice(i, 1)[0];
            next_tracks.push(track_id);
            return track_id;
        }

        document.addEventListener('keydown', e => {
            if (e.shiftKey && e.code == 'KeyR') {
                record();
            } else if (e.code == 'Space') {
                e.preventDefault();
                if (!play_record_disable) {
                    playRecord();
                }
            } else if (e.code == 'Escape') {
                if (filter_active) {
                    deleteFilter();
                } else {
                    stopAllSounds();
                }
            } else {
                if (right_click) {
                    right_click = false;
                    sound_keys[e.code] = next_key_sound;
                    keys_state[e.code] = 'up';
                }

                if (e.code in sound_keys) {
                    if (keys_state[e.code] == 'up') {
                        next_sounds.push(e.code);
                        keys_state[e.code] = 'down';
                    }
                }
            }
        });

        document.addEventListener('keyup', e => {
            if (e.code in sound_keys) {
                keys_state[e.code] = 'up';
            }
        });

        function keyPlay() {
            for (i = 0; i < next_sounds.length; i++) {
                code = next_sounds[i];
                var index = map[sound_keys[code]].file;
                var files = audio_files.files;
                var file = URL.createObjectURL(files[index]);
                var track_id = nextTrack();
                tracks[track_id].src = file;
                tracks[track_id].play();
                active_tracks.push(track_id);
                current_sound[track_id] = sound_keys[code];
                if (last_played != null) {
                    resetPoint(last_played);
                }
                drawCurrentPoint(sound_keys[code]);
                last_played = sound_keys[code];
                var text = document.getElementById("sound_name");
                text.innerHTML = files[index].name;
            }
            next_sounds = [];
            setTimeout(keyPlay);
        }

        cv.addEventListener('contextmenu', e => {
            e.preventDefault();

            xs = e.offsetX;
            ys = e.offsetY;
            var dist_min = 100;
            var i_min = null;

            for (let i = 0; i < nbSounds; i++) {
                var x = positions[i][0];
                var y = positions[i][1];
                var dx = xs - x;
                var dy = ys - y;
                var dist = dx * dx + dy * dy;
                if (dist < dist_min) {
                    dist_min = dist;
                    i_min = i;
                }
            }

            if (dist_min < pointRadius * pointRadius) {
                right_click = true;
                next_key_sound = i_min;
            }
        });

        // Listen to mouse down event 
        cv.addEventListener('mousedown', e => {
            e.preventDefault();

            down = true;
            previous_xs = e.offsetX;
            previous_ys = e.offsetY;

            // If shiftKey is pressed, select the sound by changing the color of its stroke
            if (e.shiftKey) {
                xs = e.offsetX;
                ys = e.offsetY;
                var dist_min = 100;
                var i_min = null;

                for (let i = 0; i < nbSounds; i++) {
                    var x = positions[i][0];
                    var y = positions[i][1];
                    var dx = xs - x;
                    var dy = ys - y;
                    var dist = dx * dx + dy * dy;
                    if (dist < dist_min) {
                        dist_min = dist;
                        i_min = i;
                    }
                }

                if (dist_min < pointRadius * pointRadius) {
                    if (selected.includes(i_min)) {
                        index_current = selected.indexOf(i_min);
                        selected.splice(index_current, 1);
                    } else {
                        selected.push(i_min);
                    }
                    ctx.clearRect(0, 0, c.width, c.height);
                    createMap();
                }
            }

            // Trigger the closest sound if it is close enough
            xs = e.offsetX;
            ys = e.offsetY;
            var dist_min = 100;
            var i_min = null;

            xgrid = Math.floor(xs / (2 * pointRadius));
            ygrid = Math.floor(ys / (2 * pointRadius));
            gridSounds = grid[xgrid][ygrid];

            gridSounds.forEach(i => {
                var x = positions[i][0];
                var y = positions[i][1];
                var dx = xs - x;
                var dy = ys - y;
                var dist = dx * dx + dy * dy;
                if (dist < dist_min) {
                    dist_min = dist;
                    i_min = i;
                }
            });

            if (dist_min < pointRadius * pointRadius) {
                if (last_played != null) {
                    resetPoint(last_played);
                }
                drawCurrentPoint(i_min);
                index = map[i_min].file;
                var files = audio_files.files;
                var file = URL.createObjectURL(files[index]);
                if (playing_mode == "single") {
                    if (!audio_player.paused) {
                        var index_track = active_tracks.indexOf(0);
                        active_tracks.splice(index_track, 1);
                    }
                    audio_player.src = file;
                    current_sound[0] = i_min;
                    audio_player.play();
                    active_tracks.push(0);
                } else {
                    var track_id = nextTrack();
                    tracks[track_id].src = file;
                    current_sound[track_id] = i_min;
                    tracks[track_id].play();
                    active_tracks.push(track_id);
                }
                last_played = i_min;
                var text = document.getElementById("sound_name");
                text.innerHTML = files[index].name;

            }
        });

        // Listen to mouse move event
        cv.addEventListener('mousemove', e => {

            // If the mouse button i down, move the map
            if (down) {
                centerX = centerX - (e.offsetX - previous_xs) / (scale * c.width);
                centerY = centerY - (e.offsetY - previous_ys) / (scale * c.height);
                previous_xs = e.offsetX;
                previous_ys = e.offsetY;
                upDatePositions(scale, centerX, centerY);
                upDateGrid();
                ctx.clearRect(0, 0, c.width, c.height);
                createMap();
            }

            // Trigger the closest sound if it is close enough
            else {
                if (!e.shiftKey) {
                    let now = Date.now()
                    if (now - last > sleep) {
                        xs = e.offsetX;
                        ys = e.offsetY;
                        var dist_min = 100;
                        var i_min = null;

                        xgrid = Math.floor(xs / (2 * pointRadius));
                        ygrid = Math.floor(ys / (2 * pointRadius));
                        gridSounds = grid[xgrid][ygrid];

                        gridSounds.forEach(i => {
                            var x = positions[i][0];
                            var y = positions[i][1];
                            var dx = xs - x;
                            var dy = ys - y;
                            var dist = dx * dx + dy * dy;
                            if (dist < dist_min) {
                                dist_min = dist;
                                i_min = i;
                            }
                        });

                        if (dist_min > pointRadius * pointRadius) {
                            inpoint = false;
                        } else {
                            if (last_played == i_min) {
                                if (!inpoint) {
                                    index = map[i_min].file;
                                    var files = audio_files.files;
                                    var file = URL.createObjectURL(files[index]);
                                    if (playing_mode == "single") {
                                        if (!audio_player.paused) {
                                            var index_track = active_tracks.indexOf(0);
                                            active_tracks.splice(index_track, 1);
                                        }
                                        audio_player.src = file;
                                        current_sound[0] = i_min;
                                        audio_player.play();
                                        active_tracks.push(0);
                                    } else {
                                        var track_id = nextTrack();
                                        tracks[track_id].src = file;
                                        current_sound[track_id] = i_min;
                                        tracks[track_id].play();
                                        active_tracks.push(track_id);
                                    }
                                    last = Date.now();
                                    inpoint = true;
                                }
                            }
                            if (last_played != i_min) {
                                if (last_played != null) {
                                    resetPoint(last_played);
                                }
                                drawCurrentPoint(i_min);
                                index = map[i_min].file;
                                var files = audio_files.files;
                                var file = URL.createObjectURL(files[index]);
                                if (playing_mode == "single") {
                                    if (!audio_player.paused) {
                                        var index_track = active_tracks.indexOf(0);
                                        active_tracks.splice(index_track, 1);
                                    }
                                    audio_player.src = file;
                                    current_sound[0] = i_min;
                                    audio_player.play();
                                    active_tracks.push(0);
                                } else {
                                    var track_id = nextTrack();
                                    tracks[track_id].src = file;
                                    current_sound[track_id] = i_min;
                                    tracks[track_id].play();
                                    active_tracks.push(track_id);
                                }
                                last = Date.now();
                                last_played = i_min;
                                inpoint = true;
                                var text = document.getElementById("sound_name");
                                text.innerHTML = files[index].name;
                            }

                        }
                    }
                }
            }
        });

        // Recenter the map
        function recenter() {
            scale = 1;
            centerX = 0.5;
            centerY = 0.5;

            upDatePositions(scale, centerX, centerY);
            upDateGrid();
            ctx.clearRect(0, 0, c.width, c.height);
            createMap();

        }

        // Update the position of the points on the map according to the scale and center
        function upDatePositions(scale, centerX, centerY) {
            positions = [];
            for (let i = 0; i < nbSounds; i++) {
                offsetX = c.width * (0.5 - scale * centerX);
                offsetY = c.height * (0.5 - scale * centerY);
                var x = (0.7 * map[i].point[0] + 0.15) * c.width * scale + offsetX;
                var y = (0.7 * map[i].point[1] + 0.15) * c.height * scale + offsetY;
                positions.push([x, y]);
            }
        }

        // Add a point on the canvas when filter is not active
        function addPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25);
            var g = Math.floor(map[i].color[1] / 1.25);
            var b = Math.floor(map[i].color[2] / 1.25);
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];
            ctx.beginPath();
            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = background_color;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Add a point on the canvas when filter is active
        function addPointFilter(i) {
            if (filtered.includes(i)) {
                var r = Math.floor(map[i].color[0] / 1.25);
                var g = Math.floor(map[i].color[1] / 1.25);
                var b = Math.floor(map[i].color[2] / 1.25);
                var colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            } else {
                var colorPoint = 'rgb(225,225,225)';
            }
            var x = positions[i][0];
            var y = positions[i][1];
            ctx.beginPath();
            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = background_color;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Reset the point after playing
        function resetPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25);
            var g = Math.floor(map[i].color[1] / 1.25);
            var b = Math.floor(map[i].color[2] / 1.25);
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];

            ctx.beginPath();

            ctx.fillStyle = background_color;
            ctx.strokeStyle = background_color;
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = background_color;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Highlight current point
        function drawCurrentPoint(i) {
            var r = Math.floor(map[i].color[0] / 1.25) + 40;
            var g = Math.floor(map[i].color[1] / 1.25) + 40;
            var b = Math.floor(map[i].color[2] / 1.25) + 40;
            let colorPoint = 'rgb(' + r + ',' + g + ',' + b + ')';
            var x = positions[i][0];
            var y = positions[i][1];
            ctx.beginPath();
            ctx.fillStyle = colorPoint;
            if (selected.includes(i)) {
                ctx.strokeStyle = 'rgb(0,0,0)';
            } else {
                ctx.strokeStyle = colorPoint;
            }
            ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Initiate the grid
        function initiateGrid() {
            var gridWidth = Math.floor(c.width / (2 * pointRadius));
            var gridHeight = Math.floor(c.height / (2 * pointRadius));
            grid = new Array(gridWidth);
            for (let i = 0; i < gridWidth; i++) {
                grid[i] = new Array(gridHeight);
                for (let j = 0; j < gridHeight; j++) {
                    grid[i][j] = [];
                }
            }
        }

        // Update the grid
        function upDateGrid() {
            var gridWidth = Math.floor(c.width / (2 * pointRadius));
            var gridHeight = Math.floor(c.height / (2 * pointRadius));
            grid = new Array(gridWidth);
            for (let i = 0; i < gridWidth; i++) {
                grid[i] = new Array(gridHeight);
                for (let j = 0; j < gridHeight; j++) {
                    grid[i][j] = [];
                }
            }

            if (filter_active) {
                for (let i = 0; i < nbSounds; i++) {
                    if (filtered.includes(i)) {
                        console.log(i);
                        var xgrid = Math.floor(positions[i][0] / (2 * pointRadius));
                        var ygrid = Math.floor(positions[i][1] / (2 * pointRadius));
                        if (xgrid >= 0 && ygrid >= 0 && xgrid < gridWidth && ygrid < gridHeight) {
                            if (xgrid >= 1 && ygrid >= 1 && xgrid < gridWidth - 1 && ygrid < gridHeight - 1) {
                                for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                                    for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                        grid[x][y].push(i);
                                    }
                                }
                            } else if (xgrid == 0 && ygrid >= 1 && ygrid < gridHeight - 1) {
                                for (let x = xgrid; x <= xgrid + 1; x++) {
                                    for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            } else if (xgrid == gridWidth - 1 && ygrid >= 1 && ygrid < gridHeight - 1) {
                                for (let x = xgrid - 1; x <= xgrid; x++) {
                                    for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == 0) {
                                for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                                    for (let y = ygrid; y <= ygrid + 1; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == gridHeight - 1) {
                                for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                                    for (let y = ygrid - 1; y <= ygrid; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            } else if (xgrid == 0 && ygrid == 0) {
                                for (let x = xgrid; x <= xgrid + 1; x++) {
                                    for (let y = ygrid; y <= ygrid + 1; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            } else if (xgrid == gridWidth - 1 && ygrid == 0) {
                                for (let x = xgrid - 1; x <= xgrid; x++) {
                                    for (let y = ygrid; y <= ygrid + 1; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            } else if (xgrid == 0 && ygrid == gridHeight - 1) {
                                for (let x = xgrid; x <= xgrid + 1; x++) {
                                    for (let y = ygrid - 1; y <= ygrid; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            } else if (xgrid == gridWidth - 1 && ygrid == gridHeight - 1) {
                                for (let x = xgrid - 1; x <= xgrid; x++) {
                                    for (let y = ygrid - 1; y <= ygrid; y++) {
                                        grid[x][y].push(i)
                                    }
                                }
                            }
                        }
                    }
                }

            } else {
                for (let i = 0; i < nbSounds; i++) {
                    var xgrid = Math.floor(positions[i][0] / (2 * pointRadius));
                    var ygrid = Math.floor(positions[i][1] / (2 * pointRadius));
                    if (xgrid >= 0 && ygrid >= 0 && xgrid < gridWidth && ygrid < gridHeight) {
                        if (xgrid >= 1 && ygrid >= 1 && xgrid < gridWidth - 1 && ygrid < gridHeight - 1) {
                            for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                                for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                    grid[x][y].push(i);
                                }
                            }
                        } else if (xgrid == 0 && ygrid >= 1 && ygrid < gridHeight - 1) {
                            for (let x = xgrid; x <= xgrid + 1; x++) {
                                for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        } else if (xgrid == gridWidth - 1 && ygrid >= 1 && ygrid < gridHeight - 1) {
                            for (let x = xgrid - 1; x <= xgrid; x++) {
                                for (let y = ygrid - 1; y <= ygrid + 1; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == 0) {
                            for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                                for (let y = ygrid; y <= ygrid + 1; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        } else if (xgrid >= 1 && xgrid < gridWidth - 1 && ygrid == gridHeight - 1) {
                            for (let x = xgrid - 1; x <= xgrid + 1; x++) {
                                for (let y = ygrid - 1; y <= ygrid; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        } else if (xgrid == 0 && ygrid == 0) {
                            for (let x = xgrid; x <= xgrid + 1; x++) {
                                for (let y = ygrid; y <= ygrid + 1; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        } else if (xgrid == gridWidth - 1 && ygrid == 0) {
                            for (let x = xgrid - 1; x <= xgrid; x++) {
                                for (let y = ygrid; y <= ygrid + 1; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        } else if (xgrid == 0 && ygrid == gridHeight - 1) {
                            for (let x = xgrid; x <= xgrid + 1; x++) {
                                for (let y = ygrid - 1; y <= ygrid; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        } else if (xgrid == gridWidth - 1 && ygrid == gridHeight - 1) {
                            for (let x = xgrid - 1; x <= xgrid; x++) {
                                for (let y = ygrid - 1; y <= ygrid; y++) {
                                    grid[x][y].push(i)
                                }
                            }
                        }
                    }
                }
            }
        }

        // Draw the map on the canvas
        function createMap() {
            if (filter_active) {
                for (let i = 0; i < nbSounds; i++) {
                    if (!filtered.includes(i)) {
                        addPointFilter(i);
                    }
                }
                for (const i of filtered) {
                    addPointFilter(i);
                }
            } else {
                for (let i = 0; i < nbSounds; i++) {
                    addPoint(i);
                }
            }
        }

        // Call the API to compute the map
        function computeMap() {
            resetMap();
            var totalfiles = document.getElementById('audio_files').files.length;
            const text = document.getElementById("text_compute");

            if (totalfiles > 0) {
                text.innerHTML = "Computing...";

                var formData = new FormData();

                // Read selected files
                for (var index = 0; index < totalfiles; index++) {
                    formData.append("files[]", document.getElementById('audio_files').files[index]);
                }

                fetch('http://localhost:5000/api', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.json())
                    .then(sound_map => {
                        map = JSON.parse(sound_map['sound_map']);
                        for (sound in map) {
                            nbSounds++;
                        };
                        recenter();
                        createMap();
                        text.innerHTML = "";
                    })
            } else {
                text.innerHTML = "No file uploaded !";
            }
        }

        // Reset the map
        function resetMap() {
            ctx.clearRect(0, 0, c.width, c.height);
            nbSounds = 0;
            last_played = null;
        }

    </script>
</body>

</html>